const { transformTokens } = require("token-transformer");
const StyleDictionary = require("style-dictionary");
const _ = require("lodash");
const fs = require("fs");
const path = require("path");

// Tokens generated by Tokens Studio
const rawTokens = require("../tokens.json");

const BUILD_PATH = "dist/web/";
// Define global set name constant
const GLOBAL = "core";

// Custom transform for box shadow values
StyleDictionary.registerTransform({
  type: "value",
  name: "boxShadow",
  matcher: (token) => token.type === "boxShadow",
  transformer: (token) =>
    token.value
      .reduce((boxShadowStrings, currentValue) => {
        const { x, y, spread, blur, color, type } = currentValue;
        const maybeInset = type === "innerShadow" ? "inset" : "";
        return [
          ...boxShadowStrings,
          `${x}px ${y}px ${spread}px ${blur}px ${color} ${maybeInset}`.trim(),
        ];
      }, [])
      .join(", "),
});

// Custom transform for box shadow values
StyleDictionary.registerTransform({
  type: "value",
  name: "px",
  matcher: (token) =>
    [
      "borderRadius",
      "borderWidth",
      "dimension",
      "fontSizes",
      "spacing",
    ].includes(token.type),
  transformer: (token) => `${token.value}px`,
});

StyleDictionary.registerFormat({
  name: "css/variables/dark",
  formatter: _.template(fs.readFileSync("templates/web-dark.template")),
});

StyleDictionary.registerFormat({
  name: "css/variables/light",
  formatter: _.template(fs.readFileSync("templates/web-light.template")),
});

// Write CSS exports to package.json on build
StyleDictionary.registerAction({
  name: "createCSSExports",
  do: function (dictionary, config) {
    const packageJson = require("../package.json");
    if (!packageJson.exports) {
      packageJson.exports = {};
    }
    config.files.forEach((file) => {
      const filePath = path.join(config.buildPath, file.destination);
      const importName = `./${file.destination.split(".")[0]}`;
      try {
        fs.statSync(filePath);
      } catch {
        return;
      }
      packageJson.exports[importName] = `./${filePath}`;
      fs.writeFileSync("package.json", JSON.stringify(packageJson, null, 2));
    });
  },
  undo: function (dictionary, config) {
    const packageJson = require("../package.json");
    if (!packageJson.exports) {
      return;
    }
    config.files.forEach((file) => {
      const importName = `./${file.destination.split(".")[0]}`;
      if (packageJson.exports[importName]) {
        delete packageJson.exports[importName];
      }
      fs.writeFileSync("package.json", JSON.stringify(packageJson, null, 2));
    });
  },
});

// Write JS exports to index.js on build
StyleDictionary.registerAction({
  name: "createJSExports",
  do: function (dictionary, config) {
    const packageJson = require("../package.json");
    let indexFile = fs.readFileSync("dist/web/index.js", {
      encoding: "utf8",
    });
    if (!packageJson.exports) {
      packageJson.exports = {};
    }
    config.files.forEach((file) => {
      const filePath = path.join(config.buildPath, file.destination);
      const importName = `./js/${file.destination.split(".")[0]}`;
      try {
        fs.statSync(filePath);
      } catch {
        return;
      }
      packageJson.exports[importName] = `./${filePath}`;
      fs.writeFileSync("package.json", JSON.stringify(packageJson, null, 2));
      indexFile = indexFile.concat(
        `\nexport * as ${_.camelCase(file.destination.split(".")[0])} from './${
          file.destination
        }';`
      );
    });
    fs.writeFileSync("dist/web/index.js", indexFile);
  },
  undo: function (dictionary, config) {
    const packageJson = require("../package.json");
    let indexFileExports = fs
      .readFileSync("dist/web/index.js", {
        encoding: "utf8",
      })
      .split(/\n/);
    if (!packageJson.exports) {
      return;
    }
    config.files.forEach((file) => {
      const importName = `./js/${file.destination.split(".")[0]}`;
      if (packageJson.exports[importName]) {
        delete packageJson.exports[importName];
      }
      fs.writeFileSync("package.json", JSON.stringify(packageJson, null, 2));
      indexFileExports = indexFileExports.filter(
        (exportStatement) => !exportStatement.includes(file.destination)
      );
    });
    fs.writeFileSync("dist/web/index.js", indexFileExports.join("\n"));
  },
});

// Get set keys for all sets besides our global set
const nonGlobalSetKeys = Object.keys(rawTokens).filter(
  (key) => key !== GLOBAL && !key.startsWith("$")
);

// Format our Tokens Setudio token sets for Style Dictionary
const styleDictionaryJSON = nonGlobalSetKeys.reduce(
  (accumulator, set) => ({
    ...accumulator,
    [set]: transformTokens(rawTokens, [GLOBAL, set], [GLOBAL], {
      expandTypography: true,
    }),
  }),
  []
);

styleDictionaryJSON[GLOBAL] = transformTokens(rawTokens, [GLOBAL], [], {
  expandTypography: true,
});

const styleDictionaries = [GLOBAL, ...nonGlobalSetKeys].map((key) => {
  const theme = key.toLowerCase().match(/(backcountry|hunt|offroad)/)?.[1];
  let formatter = "css/variables";
  if (/dark/.test(key)) {
    formatter = `${formatter}/dark`;
  }
  if (/light/.test(key)) {
    formatter = `${formatter}/light`;
  }
  return StyleDictionary.extend({
    tokens: styleDictionaryJSON[key],
    platforms: {
      css: {
        transformGroup: "css",
        transforms: [
          "attribute/cti",
          "name/cti/kebab",
          "time/seconds",
          "content/icon",
          "size/rem",
          "color/css",
          "boxShadow",
          "px",
        ],
        prefix: "ys",
        buildPath: BUILD_PATH,
        files: [
          {
            destination: `${_.kebabCase(key)}.css`,
            format: formatter,
            options: { theme },
          },
        ],
        actions: ["createCSSExports"],
      },
      js: {
        transforms: [
          "attribute/cti",
          "name/cti/camel",
          "size/rem",
          "color/hex",
        ],
        buildPath: BUILD_PATH,
        files: [
          {
            destination: `${_.kebabCase(key)}.js`,
            format: "javascript/es6",
          },
        ],
        actions: ["createJSExports"],
      },
    },
  });
});

module.exports = {
  buildWebTokens: async function () {
    styleDictionaries.forEach((styleDictionary) => {
      styleDictionary.cleanAllPlatforms();
      styleDictionary.buildAllPlatforms();
    });
  },
};
